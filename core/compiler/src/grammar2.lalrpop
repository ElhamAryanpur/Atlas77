use std::str::FromStr;
use common::span::{Span, BytePos};
use crate::nodes;
use crate::data_type;

//Node:
//    NodeKind
//Declaration,:
//    Function, Struct, Import, Contract, Signature
//Expression:
//   Lambda, BinaryExpression, BinaryOperator, UnaryExpression, UnaryOperator, Literal, VariableDeclaration, MatchExpression, MatchArm
//DataType:
//    DataTypeKind
grammar;

pub Program: Vec<nodes::Node> = {
    <d: Declaration*> => d
}

Declaration: nodes::Declaration = {
    <l: @L> <f: Function> <r: @R> => Nodes.new(
        nodes::NodeKind::Declaration(nodes::Declaration::Function(f)),
        Span {
            start: BytePos(l),
            end: BytePos(r),
        }
    )
}

Function: nodes::Function = {
    <l: @L> "fn" <i: Identifier> "(" <c: Comm<Arg>>")" "->" <rt: DataType> "=" <e: Expression> <r: @R> => {
        nodes::Function {
            name: i.as_str(),
            span: Span {
                start: BytePos(l),
                end: BytePos(r),
            },
            args: c.as_ref(),
            body: nodes::Node::new(
                nodes::NodeKind::Expression(e),
                Span {
                    e.span.start,
                    e.span.end,
                }
            )
        }
    }
}

Arg: (String, DataType) = {
    <n: Identifier> ":" <d: DataType> => (n, d)
}





pub DataType: data_type::DataType = {
    <l: @L> "i64" <r: @R> => DataType {
        kind: data_type::DataTypeKind::Int,
        span: Span {
            start: BytePos(l),
            end: BytePos(r),
        }
    },
    <l: @L> "bool" <r: @R> => DataType {
        kind: data_type::DataTypeKind::Bool,
        span: Span {
            start: BytePos(l),
            end: BytePos(r),
        }
    },
    <l: @L> "string" <r: @R> => DataType {
        kind: data_type::DataTypeKind::StringType,
        span: Span {
            start: BytePos(l),
            end: BytePos(r),
        }
    },
    <l: @L> "f64" <r: @R> => DataType {
        kind: data_type::DataTypeKind::Float,
        span: Span {
            start: BytePos(l),
            end: BytePos(r),
        }
    },
    <l: @L> <i: Identifier> <r: @R> => DataType {
        kind: data_type::DataTypeKind::CustomType(i.as_str()),
        span: Span {
            start: BytePos(l),
            end: BytePos(r),
        }
    },
    <l: @L> "()" <r: @R> => DataType {
        kind: data_type::DataTypeKind::Unit,
        span: Span {
            start: BytePos(l),
            end: BytePos(r),
        }
    },
    //Function type
    <l: @L> <d1: DataType> <ds: ("->" DataType)*> <r: @R> => DataType {
        kind: data_type::DataTypeKind::FunctionType(),
        span: Span {
            start: BytePos(l),
            end: BytePos(r),
        }
    }
}

Comma<Rule>: Vec<Rule> = {
    <rules: (<Rule> ",")*> <last: Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    }
}

Pipe<Rule>: Vec<Rule> = {
    <rules: ("|" <Rule> ",")*> <last: ("\\" <Rule>)> => {
        let mut rules = rules;
        rules.push(last);
        rules
    }
}

RArrow<Rule>: Vec<Rule> = {
    <rules: (<Rule> "->")*> <last: Rule> => {
        let mut rules = rules;
        rules.push(last);
        rules
    }
}

Semicolon<Rule>: Vec<Rule> = {
    <rules: (<Rule> ";")*> <last: Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    }
}

Identifier: String = <s: r"[a-zA-Z_][a-zA-Z0-9_]*"> => s.to_string()

