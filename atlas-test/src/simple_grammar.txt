struct Point:
  x: int,
  y: int


// Define a higher-order function

let map: Fn[Fn[int] -> int, List[int]] -> List[int] =
  fn(f, xs) ->
    if is_empty(xs) then
      return [];
    else
      return f(List::head(xs)) + map(f, List::tail(xs));

let main: Fn[] -> int =
  fn() ->
    let p: Point = Point(1,2);

    let double: Fn[int] -> int = fn(x) -> x * 2;
    let result: List[int] = map(double, [1, 2, 3]);

    p.x + head(result)

let fib: Fn[int] -> int =
  fn(n) ->
    if n < 2 then
      return n;
    else
      return fib(n - 1) + fib(n - 2)