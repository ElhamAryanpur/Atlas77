struct Point:
  x: int,
  y: int


// Define a higher-order function

let map: ((i64) -> i64, List[i64]) -> List[i64] = if is_empty(xs) then return [] else return f(List::head(xs)) + map(f, List::tail(xs))

let main: () -> i64 =
    let p: Point = Point(1,2);

    let double: Fn[int] -> int = fn(x) -> x * 2;
    let result: List[int] = map(double, [1, 2, 3]);

    p.x + head(result)

let fib: Fn[i64] -> i64 =
  fn(n) ->
    if n < 2 then
      return n;
    else
      return fib(n - 1) + fib(n - 2)

let fib: (n: i64) -> i64 = if n == 0 then 0 else if n == 1 then 1 else fib(n - 1) + fib(n - 2);